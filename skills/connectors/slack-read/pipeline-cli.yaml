# Expanso Pipeline: slack-read (CLI mode)
# ==========================================
#
# Read messages from Slack channels via the Slack Web API.
#
# Usage:
#   echo '{"channel":"C01234567"}' | \
#     SLACK_BOT_TOKEN=xoxb-... expanso-edge run pipeline-cli.yaml
#
#   # With search filter
#   echo '{"channel":"C01234567","query":"deploy","limit":10}' | \
#     SLACK_BOT_TOKEN=xoxb-... expanso-edge run pipeline-cli.yaml
#
# Why Expanso Edge?
#   Your Slack bot token stays on YOUR machine.
#   AI agents get clean message data — never your credentials.
#   Full audit trail of what was accessed and when.
#
# Compose with security skills inside a single pipeline:
#   auth-verify → input-validate → access-gate → slack-read →
#   pii-redact → data-fence → envelope → audit-log

name: slack-read-cli
type: pipeline

config:
  input:
    stdin:
      codec: lines

  pipeline:
    processors:
      # ═══════════════════════════════════════════════════════════════════════
      # STEP 1: Parse input and validate
      # ═══════════════════════════════════════════════════════════════════════
      - mapping: |
          meta trace_id = uuid_v4()
          meta start_time = now()

          let input = content().parse_json()
          let channel = $input.channel.or(env("SLACK_CHANNEL_ID").or(""))

          if $channel == "" {
            throw("channel is required: provide in input JSON or SLACK_CHANNEL_ID env var")
          }

          # Validate channel ID format (Slack IDs are alphanumeric, 9-11 chars)
          if !$channel.re_match("^[A-Z0-9]{1,15}$") {
            throw("invalid channel ID format: must be alphanumeric (e.g., C01234567)")
          }

          let limit = $input.limit.or(20)
          if $limit < 1 || $limit > 200 {
            throw("limit must be between 1 and 200")
          }

          meta channel = $channel
          meta limit = $limit
          meta query = $input.query.or("")
          meta since_hours = $input.since_hours.or(24)

          root.status = "initializing"
          root.channel = $channel

      - log:
          level: INFO
          message: |
            [slack-read] Reading channel=${! meta("channel") }, limit=${! meta("limit") } (trace: ${! meta("trace_id").slice(0, 8) })

      # ═══════════════════════════════════════════════════════════════════════
      # STEP 2: Build URL from validated params and fetch from Slack API
      # ═══════════════════════════════════════════════════════════════════════
      - mapping: |
          let api_url = env("SLACK_API_URL").or("https://slack.com/api")
          let oldest = now().ts_sub(meta("since_hours") + "h").ts_unix()
          let channel = meta("channel")
          let limit = meta("limit")

          root.url = $api_url + "/conversations.history?channel=" + $channel + "&limit=" + $limit.string() + "&oldest=" + $oldest.string()

      - try:
          - http:
              url: "${! this.url}"
              verb: GET
              headers:
                Authorization: "Bearer ${SLACK_BOT_TOKEN}"
                Content-Type: "application/json"
              rate_limit: slack_api
        catch:
          - mapping: |
              root.source = "slack"
              root.resource = "conversations.history"
              root.schema_version = "1.0"
              root.trace_id = meta("trace_id")
              root.error = error()
              root.data = []
              root.count = 0
              root.sensitivity = "none"
              root.metadata = {
                "skill": "slack-read",
                "mode": "cli",
                "channel": meta("channel"),
                "trace_id": meta("trace_id"),
                "success": false,
                "error": error(),
                "timestamp": now()
              }
          - log:
              level: ERROR
              message: |
                [slack-read] HTTP error: ${! error() } channel=${! meta("channel") } (trace: ${! meta("trace_id").slice(0, 8) })

      # ═══════════════════════════════════════════════════════════════════════
      # STEP 3: Verify response and structure output with canonical envelope
      # ═══════════════════════════════════════════════════════════════════════
      - mapping: |
          # If we already have an error envelope from catch, pass through
          if this.exists("error") && this.exists("source") {
            root = this
          } else {
            let response = this
            let ok = $response.ok.or(false)

            if !$ok {
              root.source = "slack"
              root.resource = "conversations.history"
              root.schema_version = "1.0"
              root.trace_id = meta("trace_id")
              root.error = $response.error.or("unknown_error")
              root.data = []
              root.count = 0
              root.sensitivity = "raw"
              root.metadata = {
                "skill": "slack-read",
                "mode": "cli",
                "channel": meta("channel"),
                "trace_id": meta("trace_id"),
                "success": false,
                "error": $response.error.or("unknown_error"),
                "timestamp": now()
              }
            } else {
              let messages = $response.messages.or([])

              # Apply optional query filter
              let query = meta("query")
              let filtered = if $query != "" {
                $messages.filter(m -> m.text.or("").lowercase().contains($query.lowercase()))
              } else {
                $messages
              }

              let structured = $filtered.map_each(m -> {
                "id": m.ts,
                "user": m.user.or("unknown"),
                "text": m.text.or(""),
                "timestamp": m.ts,
                "thread_ts": m.thread_ts.or(null),
                "reactions": m.reactions.or([]).map_each(r -> {
                  "name": r.name,
                  "count": r.count
                })
              })

              # Canonical output envelope
              root.source = "slack"
              root.resource = "conversations.history"
              root.schema_version = "1.0"
              root.trace_id = meta("trace_id")
              root.data = $structured
              root.count = $structured.length()
              root.sensitivity = "raw"
              root.metadata = {
                "skill": "slack-read",
                "mode": "cli",
                "channel": meta("channel"),
                "trace_id": meta("trace_id"),
                "message_count": $structured.length(),
                "total_available": $messages.length(),
                "query": meta("query"),
                "success": true,
                "timestamp": now()
              }
            }
          }

      - log:
          level: INFO
          message: |
            [slack-read] Retrieved ${! this.count.or(0) } messages (trace: ${! meta("trace_id").slice(0, 8) })

  output:
    stdout:
      codec: json_object

rate_limit_resources:
  - label: slack_api
    local:
      count: 10
      interval: 1s
